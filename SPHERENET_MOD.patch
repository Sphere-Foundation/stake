From ac65294787e23d7ba327ae7f8e6b33d1729613be Mon Sep 17 00:00:00 2001
From: hana <81144685+2501babe@users.noreply.github.com>
Date: Thu, 5 Feb 2026 11:05:13 -0800
Subject: [PATCH] enable 1 sol minimum delegation (#240)

---
 program/src/lib.rs                 | 18 +--------
 program/tests/program_test.rs      | 10 ++---
 program/tests/stake_instruction.rs | 60 +++++++++++++++---------------
 3 files changed, 36 insertions(+), 52 deletions(-)

diff --git a/program/src/lib.rs b/program/src/lib.rs
index 41eafb0..eee520d 100644
--- a/program/src/lib.rs
+++ b/program/src/lib.rs
@@ -7,16 +7,6 @@ pub mod entrypoint;
 
 solana_pubkey::declare_id!("Stake11111111111111111111111111111111111111");
 
-// placeholders for features
-// we have ONE feature in the current stake program we care about:
-// * stake_raise_minimum_delegation_to_1_sol /
-//   9onWzzvCzNC2jfhxxeqRgs5q7nFAAKpCUvkj6T6GJK9i this may or may not be
-//   activated by time we are done, but it should be confined to the program so
-//   we use a placeholder for now to call it out. but we can just change the
-//   program. it is unclear if or when it will ever be activated, because it
-//   requires a validator vote
-const FEATURE_STAKE_RAISE_MINIMUM_DELEGATION_TO_1_SOL: bool = false;
-
 // feature_set::reduce_stake_warmup_cooldown changed the warmup/cooldown from
 // 25% to 9%. a function is provided by the sdk,
 // new_warmup_cooldown_rate_epoch(), which returns the epoch this change
@@ -34,10 +24,6 @@ const PERPETUAL_NEW_WARMUP_COOLDOWN_RATE_EPOCH: Option<u64> = Some(0);
 /// delegation.
 #[inline(always)]
 pub fn get_minimum_delegation() -> u64 {
-    if FEATURE_STAKE_RAISE_MINIMUM_DELEGATION_TO_1_SOL {
-        const MINIMUM_DELEGATION_SOL: u64 = 1;
-        MINIMUM_DELEGATION_SOL * LAMPORTS_PER_SOL
-    } else {
-        1
-    }
+    const MINIMUM_DELEGATION_SOL: u64 = 1;
+    MINIMUM_DELEGATION_SOL * LAMPORTS_PER_SOL
 }
diff --git a/program/tests/program_test.rs b/program/tests/program_test.rs
index 2098f51..a1a9181 100644
--- a/program/tests/program_test.rs
+++ b/program/tests/program_test.rs
@@ -1048,8 +1048,8 @@ async fn program_test_split(split_source_type: StakeLifecycle) {
         }
     );
 
-    // an active or transitioning stake account cannot have less than the minimum
-    // delegation note this is NOT dependent on the minimum delegation feature.
+    // an active or transitioning stake account cannot have less than the minimum delegation
+    // this is NOT dependent on the one sol minimum delegation feature
     // there was ALWAYS a minimum. it was one lamport!
     if split_source_type.minimum_delegation_enforced() {
         // underfunded destination fails
@@ -1063,7 +1063,7 @@ async fn program_test_split(split_source_type: StakeLifecycle) {
         let e = process_instruction(&mut context, instruction, &signers)
             .await
             .unwrap_err();
-        assert_eq!(e, ProgramError::InsufficientFunds);
+        assert_eq!(e, StakeError::InsufficientDelegation.into());
 
         // underfunded source fails
         let instruction = &ixn::split(
@@ -1398,10 +1398,6 @@ async fn program_test_deactivate(activate: bool) {
     assert_eq!(e, StakeError::AlreadyDeactivated.into());
 }
 
-// XXX the original test_merge is a stupid test
-// the real thing is test_merge_active_stake which actively controls clock and
-// stake_history but im just trying to smoke test rn so lets do something
-// simpler
 #[test_matrix(
     [StakeLifecycle::Uninitialized, StakeLifecycle::Initialized, StakeLifecycle::Activating,
      StakeLifecycle::Active, StakeLifecycle::Deactivating, StakeLifecycle::Deactive],
diff --git a/program/tests/stake_instruction.rs b/program/tests/stake_instruction.rs
index 0b9e572..e8f2b5c 100644
--- a/program/tests/stake_instruction.rs
+++ b/program/tests/stake_instruction.rs
@@ -3602,24 +3602,30 @@ fn test_split_minimum_stake_delegation() {
             is_writable: true,
         },
     ];
-    // NOTE with a 1lamp minimum delegation, cases 2 and 4 merely hit the zero split error
-    // these would be InsufficientDelegation if the minimum were 1sol
     for (source_delegation, split_amount, expected_result) in [
+        // 0: source is twice minimum, we split minimum
+        // success
         (minimum_delegation * 2, minimum_delegation, Ok(())),
+        // 1: source is twice minimum, we split one less than minimum
+        // dest stake becomes underfunded
         (
             minimum_delegation * 2,
             minimum_delegation - 1,
-            Err(ProgramError::InsufficientFunds),
+            Err(StakeError::InsufficientDelegation.into()),
         ),
+        // 2: source is one less than twice minimum, we split minimum
+        // source stake becomes underfunded
         (
             (minimum_delegation * 2) - 1,
             minimum_delegation,
             Err(StakeError::InsufficientDelegation.into()),
         ),
+        // 3: source is two less than twice minimum, we split one less than minimum
+        // both stakes become underfunded
         (
             (minimum_delegation - 1) * 2,
             minimum_delegation - 1,
-            Err(ProgramError::InsufficientFunds),
+            Err(StakeError::InsufficientDelegation.into()),
         ),
     ] {
         let source_account = AccountSharedData::new_data_with_space(
@@ -3854,12 +3860,9 @@ fn test_initialized_split_destination_minimum_balance() {
 /// Ensure that `split()` correctly handles prefunded destination accounts from staked stakes.
 /// When a destination account already has funds, ensure the minimum split amount reduces
 /// accordingly.
-// NOTE it is not presently possible to test 1sol minimum delegation
-// #[test_case(feature_set_all_enabled(), &[Err(StakeError::InsufficientDelegation.into()), Err(StakeError::InsufficientDelegation.into())]; "all_enabled")]
 #[test]
 fn test_staked_split_destination_minimum_balance() {
     let mollusk = mollusk_bpf();
-    let expected_results = &[Ok(()), Ok(())];
 
     let minimum_delegation = crate::get_minimum_delegation();
     let rent = Rent::default();
@@ -3884,77 +3887,76 @@ fn test_staked_split_destination_minimum_balance() {
         },
     ];
     for (destination_starting_balance, split_amount, expected_result) in [
-        // split amount must be non zero
+        // 0: split amount must be non zero
         (
             rent_exempt_reserve + minimum_delegation,
             0,
             Err(ProgramError::InsufficientFunds),
         ),
-        // destination is fully funded:
-        // - old behavior: any split amount is OK
-        // - new behavior: split amount must be at least the minimum delegation
+        // 1: destination is fully funded
+        // split amount must still be at least the minimum delegation
         (
             rent_exempt_reserve + minimum_delegation,
-            1,
-            expected_results[0].clone(),
+            minimum_delegation - 1,
+            Err(StakeError::InsufficientDelegation.into()),
         ),
-        // if destination is only short by 1 lamport, then...
-        // - old behavior: split amount can be 1 lamport
-        // - new behavior: split amount must be at least the minimum delegation
+        // 2: destination is short by 1 lamport
+        // split amount must still be at least the minimum delegation
         (
             rent_exempt_reserve + minimum_delegation - 1,
             1,
-            expected_results[1].clone(),
+            Err(StakeError::InsufficientDelegation.into()),
         ),
-        // destination short by 2 lamports, so 1 isn't enough (non-zero split amount)
+        // 3: destination short by 2 lamports
+        // split amount must still be at least the minimum delegation
         (
             rent_exempt_reserve + minimum_delegation - 2,
             1,
-            Err(ProgramError::InsufficientFunds),
+            Err(StakeError::InsufficientDelegation.into()),
         ),
-        // destination is rent exempt, so split enough for minimum delegation
+        // 4: destination is rent exempt, so split enough for minimum delegation
         (rent_exempt_reserve, minimum_delegation, Ok(())),
-        // destination is rent exempt, but split amount less than minimum delegation
+        // 5: destination is rent exempt, but split amount less than minimum delegation
         (
             rent_exempt_reserve,
-            minimum_delegation.saturating_sub(1), // when minimum is 0, this blows up!
-            Err(ProgramError::InsufficientFunds),
+            minimum_delegation - 1,
+            Err(StakeError::InsufficientDelegation.into()),
         ),
-        // destination is not rent exempt, so any split amount fails, including enough for rent
+        // 6: destination is not rent exempt, so any split amount fails, including enough for rent
         // and minimum delegation
         (
             rent_exempt_reserve - 1,
             minimum_delegation + 1,
             Err(ProgramError::InsufficientFunds),
         ),
-        // destination is not rent exempt, but split amount only for minimum delegation
+        // 7: destination is not rent exempt, but split amount only for minimum delegation
         (
             rent_exempt_reserve - 1,
             minimum_delegation,
             Err(ProgramError::InsufficientFunds),
         ),
-        // destination is not rent exempt, so any split amount fails, including case where
+        // 8: destination is not rent exempt, so any split amount fails, including case where
         // destination has smallest non-zero balance
         (
             1,
             rent_exempt_reserve + minimum_delegation - 1,
             Err(ProgramError::InsufficientFunds),
         ),
-        // destination has smallest non-zero balance, but cannot split less than the minimum
+        // 9: destination has smallest non-zero balance, but cannot split less than the minimum
         // balance requirements minus what destination already has
         (
             1,
             rent_exempt_reserve + minimum_delegation - 2,
             Err(ProgramError::InsufficientFunds),
         ),
-        // destination has zero lamports, so any split amount fails, including at least rent
+        // 10: destination has zero lamports, so any split amount fails, including at least rent
         // exempt reserve plus minimum delegation
         (
             0,
             rent_exempt_reserve + minimum_delegation,
             Err(ProgramError::InsufficientFunds),
         ),
-        // destination has zero lamports, but split amount is less than rent exempt reserve
+        // 11: destination has zero lamports, but split amount is less than rent exempt reserve
         // plus minimum delegation
         (
             0,
-- 
2.39.5 (Apple Git-154)

